{ parameter
    (or (or (pair %add_template
               (string %name)
               (lambda %originateFunc
                  (pair (pair (pair (address %marketplaceAddress) (address %minterAddress))
                              (pair (address %registryAddress) (address %tokenAddress)))
                        bytes)
                  (pair (pair (address %address) (bytes %metadata)) (operation %operation))))
            (pair %create_proxy (bytes %params) (string %templateName)))
        (or (address %is_originated_contract) (string %remove_template))) ;
  storage
    (pair (pair (pair %data
                   (pair (address %marketplaceAddress) (address %minterAddress))
                   (pair (address %registryAddress) (address %tokenAddress)))
                (big_map %originatedContracts address bytes))
          (map %templates
             string
             (lambda
                (pair (pair (pair (address %marketplaceAddress) (address %minterAddress))
                            (pair (address %registryAddress) (address %tokenAddress)))
                      bytes)
                (pair (pair (address %address) (bytes %metadata)) (operation %operation))))) ;
  code { UNPAIR ;
         IF_LEFT
           { IF_LEFT
               { SWAP ;
                 DUP ;
                 DUG 2 ;
                 CDR ;
                 SWAP ;
                 DUP ;
                 DUG 2 ;
                 CDR ;
                 DIG 2 ;
                 CAR ;
                 SWAP ;
                 SOME ;
                 SWAP ;
                 UPDATE ;
                 SWAP ;
                 CAR ;
                 PAIR ;
                 NIL operation ;
                 PAIR }
               { SWAP ;
                 DUP ;
                 DUG 2 ;
                 CDR ;
                 SWAP ;
                 DUP ;
                 DUG 2 ;
                 CDR ;
                 GET ;
                 IF_NONE { PUSH string "Template is not found" ; FAILWITH } {} ;
                 SWAP ;
                 CAR ;
                 DUP 3 ;
                 CAR ;
                 CAR ;
                 PAIR ;
                 EXEC ;
                 SWAP ;
                 DUP ;
                 DUG 2 ;
                 CDR ;
                 DUP 3 ;
                 CAR ;
                 CDR ;
                 DUP 3 ;
                 CAR ;
                 CDR ;
                 DUP 4 ;
                 CAR ;
                 CAR ;
                 SWAP ;
                 SOME ;
                 SWAP ;
                 UPDATE ;
                 DIG 3 ;
                 CAR ;
                 CAR ;
                 PAIR ;
                 PAIR ;
                 NIL operation ;
                 DIG 2 ;
                 CDR ;
                 CONS ;
                 PAIR } }
           { IF_LEFT
               { DROP ; NIL operation ; PAIR }
               { SWAP ;
                 DUP ;
                 DUG 2 ;
                 CDR ;
                 SWAP ;
                 NONE (lambda
                         (pair (pair (pair address address) (pair address address)) bytes)
                         (pair (pair address bytes) operation)) ;
                 SWAP ;
                 UPDATE ;
                 SWAP ;
                 CAR ;
                 PAIR ;
                 NIL operation ;
                 PAIR } } } }

